/*********************************************************************
 *
 * Collection of heuristic and metaheuristic algorithms
 *
 * Copyright (C) 2018-2020  Lluís Alemany Puig
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Contact: Lluís Alemany Puig (lluis.alemany.puig@gmail.com)
 * 
 *********************************************************************/

#pragma once

// C++ includes
#include <vector>
#include <random>

// metaheursitics includes
#include <metaheuristics/algorithms/genetic_algorithms/genetic_algorithm.hpp>
#include <metaheuristics/structures/individual.hpp>
#include <metaheuristics/structures/problem.hpp>

namespace metaheuristics {
namespace algorithms {

/**
 * @brief Implementation of the BRKGA.
 * 
 * BRKGA stands for Biased Random-Key Genetic Algorithm.
 * 
 * Given an instance of a problem @e p, with cost @e c,
 * the algorithm implemented in @ref execute_algorithm(problem<G>*, double&)
 * roughly follows the following pseudocode:
 * - Initialise the population with @ref genetic_algorithm::pop_size mutants
 * - Track the @ref N_ELITE best individuals (see @ref elite_set)
 * - For as many generations as @ref genetic_algorithm::N_GEN :
 * 		- Make the next generation Ng.
 * 		- Copy the best @ref N_ELITE individuals into @e Ng (in the range [0, @ref N_ELITE)).
 * 		- Generate mutants in the range
 * 			[ @ref N_ELITE, @ref N_ELITE + @ref genetic_algorithm::N_MUTANT)).
 * 		- Generate the crossover individuals in the range
 * 			[ @ref N_ELITE + @ref genetic_algorithm::N_MUTANT, @ref genetic_algorithm::pop_size).
 * - Find the individual with the largest fit and decdode the chromosome.
 *   Store the result in @e p. Store the cost of the solution in @e c.
 * 
 * A more complete description of this algorithm can be found in this paper:
 \verbatim
 Biased random-key genetic algorithms for combinatorial optimization
 Gonçalves, José Fernando and Resende, Mauricio G. C.
 1995, Journal of Heuristics, Volume 17, Number 5
 ISSN: 1381-1231
 \endverbatim
 * 
 * In this algorithm the @ref genetic_algorithm::population is split into
 * three groups:
 * - The individuals within the range [0, @ref N_ELITE), are
 * elite individuals.
 * - Those in [ @ref N_ELITE, @ref N_ELITE + @ref genetic_algorithm::N_MUTANT) are
 * mutant individuals.
 * - The rest of @ref genetic_algorithm::population
 * (range [ @ref N_ELITE + @ref genetic_algorithm::N_MUTANT, @ref genetic_algorithm::pop_size)),
 * are crossover individuals.
 * 
 * This algorithm needs the implementation of the following methods:
 * - @ref problem::clone
 * - @ref problem::decode
 * 
 * See @ref genetic_algorithm for information on compilation flags.
 * 
 * @param G The type of the engine of the random generator (see metaheuristics::drng).
 * @param size_t Type of the numbers generated by the discrete random generator (see metaheuristics::drng).
 * @param double Type of the numbers generated by the continuous random generator (see metaheuristics::crng).
 */
template<
	class G = std::default_random_engine
>
class brkga : public genetic_algorithm<G> {
	public:
		/// Constructor.
		brkga();
		/**
		 * @brief Constructor with parameters.
		 * @param p_size The total size of the population (see @ref genetic_algorithm::pop_size).
		 * @param m_size The amount of mutant individuals (see @ref genetic_algorithm::N_MUTANT).
		 * @param e_size The amount of elite individuals (see @ref N_ELITE).
		 * @param n_gen The number of generations (see @ref genetic_algorithm::N_GEN).
		 * @param chrom_size The size of each individual's chromosome (see @ref chrom_size).
		 * @param i_prob Inheritance probability (see @ref genetic_algorithm::in_prob).
		 */
		brkga
		(
			size_t p_size,
			size_t m_size,
			size_t e_size,
			size_t n_gen,
			size_t chrom_size,
			double i_prob
		);
		/// Destructor.
		virtual ~brkga();
		
		/**
		 * @brief Resets the algorithm to its initial state.
		 * 
		 * Sets to 0 the variable @ref elite_copying_time. Calls
		 * the function @ref genetic_algorithm::reset_genetic_algorithm().
		 */
		void reset_algorithm();
		
		/**
		 * @brief Returns the individual with the highest fitness.
		 * 
		 * This individual is retrieved from @ref elite_set.
		 */
		const structures::individual& get_best_individual() const;
		
		/**
		 * @brief Executes the BRKGA algorithm.
		 * 
		 * @param[in] p The instance of the problem.
		 * @param[in] c The cost of the instance @e p at the beginning of
		 * the execution.
		 * @param[out] p Whence the algorithm has finished @e p contains
		 * an improved solution to the problem.
		 * @param[out] c The cost of the solution stored at @e p at the
		 * end of the execution of the algorithm.
		 */
		bool execute_algorithm(structures::problem<G> *p, double& c);
		
		/**
		 * @brief Prints the performance of the algorithm.
		 * 
		 * Prints to standard output a message with the following format:
		\verbatim
		RKGA algorithm performance:
			Total generation average:          DOUBLE s
			Average generation average:        DOUBLE s
			Total copying elite time:          DOUBLE s
			Average copying elite time:        DOUBLE s
			Total mutant generation time:      DOUBLE s
			Average mutant generation time:    DOUBLE s
			Total crossover generation time:   DOUBLE s
			Average crossover generation time: DOUBLE s
		\endverbatim
		 */
		void print_performance() const;

	protected:
		/// Discrete random generator for values in [0, @ref N_ELITE)
		random::drandom_generator<G,size_t> elite_rng;

		/// Discrete random generator
		/// Execution time spent in copying elite individuals.
		double elite_copying_time;
		/// Amount of elite individuals in the population.
		size_t N_ELITE;
		/**
		 * @brief Set of elite individuals of the population.
		 *
		 * Stored as pairs of (fitness, index), where index points to
		 * a position in @ref genetic_algorithm::population.
		 */
		std::vector<std::pair<double, size_t> > elite_set;

	protected:

		// Information display functions
		/// Display to standard output the elite individuals
		void print_elite_set() const;

		// Algorithm-related functions
		/**
		 * @brief Implementation of the parents choice.
		 * @param[out] p1 Contains an index to an elite individual.
		 * @param[out] p2 Contains an index to a non-elite individual.
		 */
		void get_two_parents(size_t& p1, size_t& p2);
		/**
		 * @brief Copy the elite individuals.
		 *
		 * Copy the elite individuals in @ref genetic_algorithm::population to @e next_gen,
		 * within the range [ @e m, @e m + @ref N_ELITE).
		 *
		 * @param[in] p An empty instance of the problem<G>.
		 * @param[out] next_gen A population set with the elite individuals
		 * from @ref genetic_algorithm::population in the range [ @e m, @e m + @ref N_ELITE).
		 * @param[out] m Position
		 * @pre @e m < @ref genetic_algorithm::pop_size
		 */
		void copy_elite_individuals
		(const structures::problem<G> *p, population_set& next_gen, size_t& m);
		/**
		 * @brief Returns whether the @e i-th individual is an elite individual or not.
		 * @pre @e i < @ref genetic_algorithm::pop_size.
		 */
		bool is_elite_individual(size_t idx) const;
		/**
		 * @brief Keeps track of the elite individuals.
		 *
		 * "Sorts" the population by fitness and stores the index and the
		 * fitness of the @ref N_ELITE first individuals with largest
		 * fitness in @ref elite_set.
		 */
		void track_elite_individuals();

		// Sanity check
		/**
		 * @brief Makes sure that the different populations sizes are correct.
		 *
		 * Checks that @ref genetic_algorithm::N_MUTANT < @ref genetic_algorithm::pop_size. Basically, a sanity check.
		 */
		bool are_set_sizes_correct() const;
};

} // -- namespace algorithms
} // -- namespace metaheuristics

#include <metaheuristics/algorithms/genetic_algorithms/brkga.cpp>
